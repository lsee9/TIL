###### 210427_wed

##### Django REST Framework

<hr>

###### 오늘의 목차 :sunflower:

### DFR

- **CURD**
- **1:N Model Relationship**

##### :woman_cartwheeling: DFR 뿌셔뿌셔 :man_cartwheeling:

<hr>
<br>

## 기본 설정

- 가상환경 설정

```shell
$ python -m venv venv
$ source venv/Scripts/activate
```

- 장고 설치

```shell
$ pip install django
```

- 프로젝트 생성
  - (.)현재 위치에 프로젝트 생성

```shell
$ django-admin startproject myapi .
```

- 추가 프로그램 설치
  - django-seed : db에 랜덤으로 임의의 값을 넣음
  - djangorestframework : 이제 배울 것!!
  - django-extensions, ipython : shell plus이용 (라인 할줄 입력하면서 어떤 값 있는지 뽑아내기 편리한 인터페이스 사용 위한 것)

```shell
$ pip install django-seed djangorestframework django-extensions ipython
```
- 설치한 프로그램 저장
```shell
$ pip freeze > requirements.txt
```

- settings.py

```python
INSTALLED_APPS = [
    'django_seed',
    'django_extensions',
    'rest_framework',
    ...
]
```

- app 생성

```shell
$ python manage.py startapp articles
```

```python
INSTALLED_APPS = [
    'articles',
    ...
]
```

<br>

<br>

#### 오늘 할 것!

> 게시글 CRUD를 작성하자!
>
> :thinking: 이전과 뭐가 다를까??
>
> - django만 사용할 때는 HTML문서를 응답으로 보내줬다면!!
> - 이번엔 `Json형식으로 응답`을 보내주자!!!
> - 이때 **REST에 맞게 작성**하자

<br>

#### :cherries: API가 RESTful 하다?!!?! :cherries:

- 실제로 url 구성, 사용하는 method는 개발자 마음대로!!!
- 그치만 너무 다양하면 서버 하나하나 보기가 너무 힘들다
- 보기 편하도록 만들어진 **하나의 표준**이 **REST**
- `사용할 규칙` 
  - url : 자원만 나타내고, 동작은 포함하지 않는다
  - CRUD동작 => GET, POST, PUT, DELETE Method를 사용해서 구현한다
- REST는 가이드일 뿐 필수는 아니라는 사실
- 적당히 알아보기 좋게끔 디자인 하도록 하자

<br>

<br>

# 1. CRUD

#### api/urls.py

- url의 버전을 나누는 이유??
  - 보통 버전이 달라지면 전체적으로 달라짐(프레임워크? 그런 구성하는게 달라짐)
  - url마다 버전을 구분해서 쓰고싶은 것을 쓰도록 함

```python
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('api/v1/', include('articles.urls')),
]
```

<br>

#### articles/models.py

- 게시글에 해당하는 Article 모델 작성

```python
from django.db import models

class Article(models.Model):
    title = models.CharField(max_length=100)
    content = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
```

- migrate

```shell
$ python manage.py makemigrations
$ python manage.py migrate
```

<br>

#### articles/serializers.py

- **serializer**
  - model instance를 사용하기 좋게끔 python native type으로 바꿔준다
  - dict, list등 변환 + 유효성 검사
- **ArticleListSerializer**
  - 전체 게시글 리스트를 보여준다
  - id, title만 보이도록 한다

```python
from rest_framework import serializers
from .models import Article

class ArticleListSerializer(serializers.ModelSerializer):

    class Meta:
        model = Article
        fields = ('id', 'title',)
```

<br>

## 1.1 Serializer 확인하기

> 전체 CRUD를 만들기에 앞서 어떻게 생겨먹은건지 알아야하지 않겠어요???
>
> `ArticleListSerializer로 어떤 것이 만들어졌는지` 확인해봅시다!!!

#### DB에 랜덤값 넣기

- seed <app_name> --number=<넣고싶은 데이터 수> 

```shell
$ python manage.py seed articles --number=20
```

#### shell-plus

- 실행

```shell
$ python manage.py shell_plus
```

- import serializer 
  - 자동으로 생성되지 않습니다!!

```shell
from articles.serializers import ArticleListSerializer
```

- serializer instance 생성

```shell
serializer = ArticleListSerializer()

serializer
#out
ArticleListSerializer():
    id = IntegerField(label='ID', read_only=True)  #읽을수만 있음
    title = CharField(max_length=100)
```

- serializer에 article instance 넣기

```python
article = Article.objects.get(pk=1)
serializer = ArticleListSerializer(article)
```

- data 확인
  - 1번 article이 dict형태로 출력됩니다!!
  - 실제 dict는 아니지만, 3번째에서 보이듯이 dict형태로 쓸 수 있습니다

```shell
serializer.data
# out
{'id': 1, 'title': 'Everything deep newspaper building.'}

type(serializer.data)
# out
rest_framework.utils.serializer_helpers.ReturnDict

serializer.data['id']
# out
1
```

##### 그래서 serializer가 뭔데??? 

- 데이터를 serializer에 적용시키면, serializer에 정의된 fields를 가지는 dict와 유사한 형태의 데이터로 변환합니다 (형태는 사용하기에 따라 다름! 여기서는 JSON 사용!)
- 즉, `기존의 데이터`의 `형태를 변환`하는 역할을 합니다 :heavy_check_mark: :heavy_check_mark: 

- 새로운 뭔가를 생성하는게 아니라는거... 헷갈리지 맙시다!

<br>

<br>

## 1.2 CRUD 구현하자 :confetti_ball:

### :radio: READ

#### Main Page

> 모든 article list가 출력되는 부분입니다!!

- **articles/urls.py**

```python
from django.urls import path
from . import views

urlpatterns = [
    path('articles/', views.article_list),
]
```

- **articles/views.py - `article_list`**

  > 이전엔 article을 모두 가져와서 합친 뒤, html로 보여줬습니다
  >
  > 이번엔 합쳐주지 않고, **serializer를 통해 json 데이터**로 응답하겠습니다!!

  - **방식** :heavy_check_mark: 이대로 코드를 작성합시다
    1. `article을 모두 가져온다`
       - Article.objects.all() : 모든 article을 가져오며, 없으면 빈 배열
       - get_list_or_404(Article) : 모든 리스트 가져오며, 없으면 404에러
    2. `json화할 수 있도록 변환`
       - ArticleListSerializer(articles, many=True)
    3. `응답`
       - Response(serializer.date) : JSON (dict와 유사한 형태)으로 들어감
  - api_view(['GET'])
    - rest_framework로 디자인할 때는 어떤 메서드로 받는지 반드시 명시해야 합니다

```python
@api_view(['GET'])  #필수!!!!
def article_list(request):
    articles = get_list_or_404(Article)
    serializer = ArticleListSerializer(articles, many=True)
    return Response(serializer.data)
```

##### :fire: many옵션은 언제 쓰지??

> ArticleListSerializer는 딱 하나의 인스턴스를 변환하도록 설계되어있습니다
>
> 따라서 `쿼리셋을 한번에 넣어줄 때` 사용합니다!
>
> 사용하지 않으면 AttributeError가 발생합니다 ('list' object has no attribute 'title')

- :postbox: **postman** 결과 화면

  <img src="210427_DFR.assets/image-20210428020809902.png" alt="image-20210428020809902" style="zoom: 33%;" />

<br>

#### Using postman 

> REST API를 이용한 Json호출 기능 테스트에 유용합니다

- 프로그램 다운로드 후, <u>workspace 생성</u>
- <u>collection 생성</u> (ctrl + s)
- 요청 메서드 선택 (GET, POST 등)
- 테스트할 url 입력
- send => 아래에 응답 화면 출력

###### :cherry_blossom: 필요한 기능만큼 collection을 추가한 뒤, 번갈아서 사용하면 검증이 쉽습니다! :cherry_blossom:

<br>

#### Article Detail

> article 각각의 세부정보가 출력됩니다
>
> article이 가진 `모든 목록`을 보여줍니다

- articles/**serializers.py** - `ArticleSerializer`
  - ArticleListSerializer와 달리, model의 모든 요소를 보여줘야합니다
  - 이런 경우 `serializer를 서로 분리`해야합니다!!
  - 이렇듯 필요에 따라 여러개의 serializer가 생성될 수 있습니다

```python
class ArticleSerializer(serializers.ModelSerializer):

    class Meta:
        model = Article
        fields = '__all__'
```

- articles/**urls.py**
  - detail이므로 article을 식별할 수 있는 값이 필요합니다

```python
urlpatterns = [
    ...
    path('articles/<int:article_pk>/', views.article_detail),
]
```

- articles/**views.py** - `article_detail`
  - pk에 맞는 모델 인스턴스를 가져온 뒤, 변환하고 응답합니다

```python
@api_view(['GET'])
def article_detail(request, article_pk):
    article = get_object_or_404(Article, pk=article_pk)
    serializer = ArticleSerializer(article)
    return Response(serializer.data)
```

- :postbox: **postman** 결과 화면

  <img src="210427_DFR.assets/image-20210501163529309.png" alt="image-20210501163529309" style="zoom: 33%;" />

<br>

### :camera_flash: Create

#### Article Create

> main page에서 GET이면 전체 리스트가 보이고, POST면 새로운 정보가 추가됩니다!
>
> 그러므로 여기서는 POST 기능을 추가해봅시다!

- articles/urls.py
  - main page url과 동일
  
- **articles/views.py - `article_list`**

  - 요청이 GET인지, POST인지 구분하여 동작합니다

  - **POST**

    - `요청한 데이터 (request.data)`를 ArticleSerializer의 인자로 하여, `serializer 인스턴스`를 생성합니다

    - serializer 검증

      검증 `성공` : data를 저장하고, 응답 + 201 status code (데이터 정상적으로 생성됨을 안내)

      검증 `실패`: 400 bad request 

```python
from rest_framework import status

@api_view(['GET', 'POST'])
def article_list(request):
    if request.method == 'GET':
        articles = get_list_or_404(Article)
        serializer = ArticleListSerializer(articles, many=True)
        return Response(serializer.data)
    else:
        serializer = ArticleSerializer(data=request.data)
        if serializer.is_valid():
            serializer.save()
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
```

##### :cherries: 검증 실패 시 400 status code 띄우는 2가지 방법

```python
serializer.is_valid(raise_exception=True)  #is_valid 옵션 활용, 검증 실패시 status code 띄움
```

```python
return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
```

- :postbox: **postman** 결과 화면

  <img src="210427_DFR.assets/image-20210501163701307.png" alt="image-20210501163701307" style="zoom: 33%;" />

<br>

### :hourglass_flowing_sand: Update

> 하나의 article에 대해서 update를 할 수 있겠죠???
>
> article_detail에 추가합시다!

- articles/views.py - `article_detail`
  - **PUT**
    - 기존 model instance와 요청한 데이터 (request.data)를 통해 serializer를 생성합니다
    - 검증하고, 성공한다면 저장한 뒤 응답합니다

```python
@api_view(['GET', 'PUT'])
def article_detail(request, article_pk):
    article = get_object_or_404(Article, pk=article_pk)  //모든 경우에 instance가 필요하므로 가장 먼저 생성
    if request.method == 'GET':
        // 생략
    elif request.method == 'PUT':
        serializer = ArticleSerializer(instance=article, data=request.data)
        if serializer.is_valid(raise_exception=True):
            serializer.save()
            return Response(serializer.data)
```

- :postbox: **postman** 결과 화면

  <img src="210427_DFR.assets/image-20210501170834460.png" alt="image-20210501170834460" style="zoom:33%;" />

<br>

###### + Update method

> update를 위한 요청 method는 2가지가 있습니다
>
> - PUT
>   - serializer에 포함된 모든 fields의 정보를 넘겨줘야합니다
> - PATCH
>   - 포함된 값 중, 수정한 것을 제외한 나머지는 원래 값을 사용합니다
>
> :v: 현재는 수정 안한 값도 입력되어야 검증을 통과하므로, PUT을 사용합시다!!!

<br>

### :scissors: Delete

> update와 마찬가지로 하나의 article을 삭제합니다!
>
> 역시 article_detail에 기능을 추가합시다

- articles/views.py - `article_detail`
  - 해당 article을 삭제합니다
  - Response를 위해서는 data가 필요하므로, 삭제되었음을 알리는 데이터를 전달합시다

```python
@api_view(['GET', 'PUT', 'DELETE'])
def article_detail(request, article_pk):
    article = get_object_or_404(Article, pk=article_pk)
    if request.method == 'GET':
        //생략
    elif request.method == 'PUT':
        //생략
    elif request.method == 'DELETE':
        article.delete()
        data = {
            'data': f'article { article_pk }가 삭제되었습니다.',
        }
        return Response(data, status=status.HTTP_204_NO_CONTENT)

- :postbox: **postman** 결과 화면

  <img src="210427_DFR.assets/image-20210501172108593.png" alt="image-20210501172108593" style="zoom: 33%;" />

