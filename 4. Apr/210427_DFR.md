###### 210427_wed

##### Django REST Framework

<hr>

###### 오늘의 목차 :sunflower:

### DFR

- **CURD**
- **1:N Model Relationship**

##### :woman_cartwheeling: DFR 뿌셔뿌셔 :man_cartwheeling:

<hr>
<br>

## 기본 설정

- 가상환경 설정

```shell
$ python -m venv venv
$ source venv/Scripts/activate
```

- 장고 설치

```shell
$ pip install django
```

- 프로젝트 생성
  - (.)현재 위치에 프로젝트 생성

```shell
$ django-admin startproject myapi .
```

- 추가 프로그램 설치
  - django-seed : db에 랜덤으로 임의의 값을 넣음
  - djangorestframework : 이제 배울 것!!
  - django-extensions, ipython : shell plus이용 (라인 할줄 입력하면서 어떤 값 있는지 뽑아내기 편리한 인터페이스 사용 위한 것)

```shell
$ pip install django-seed djangorestframework django-extensions ipython
```
- 설치한 프로그램 저장
```shell
$ pip freeze > requirements.txt
```

- settings.py

```python
INSTALLED_APPS = [
    'django_seed',
    'django_extensions',
    'rest_framework',
    ...
]
```

- app 생성

```shell
$ python manage.py startapp articles
```

```python
INSTALLED_APPS = [
    'articles',
    ...
]
```

<br>

<br>

#### 오늘 할 것!

> 게시글 CRUD를 작성하자!
>
> :thinking: 이전과 뭐가 다를까??
>
> - django만 사용할 때는 HTML문서를 응답으로 보내줬다면!!
> - 이번엔 `Json형식으로 응답`을 보내주자!!!
> - 이때 **REST에 맞게 작성**하자

<br>

#### :cherries: API가 RESTful 하다?!!?! :cherries:

- 실제로 url 구성, 사용하는 method는 개발자 마음대로!!!
- 그치만 너무 다양하면 서버 하나하나 보기가 너무 힘들다
- 보기 편하도록 만들어진 **하나의 표준**이 **REST**
- `사용할 규칙` 
  - url : 자원만 나타내고, 동작은 포함하지 않는다
  - CRUD동작 => GET, POST, PUT, DELETE Method를 사용해서 구현한다
- REST는 가이드일 뿐 필수는 아니라는 사실
- 적당히 알아보기 좋게끔 디자인 하도록 하자

<br>

<br>

# 1. CRUD

#### api/urls.py

- url의 버전을 나누는 이유??
  - 보통 버전이 달라지면 전체적으로 달라짐(프레임워크? 그런 구성하는게 달라짐)
  - url마다 버전을 구분해서 쓰고싶은 것을 쓰도록 함

```python
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('api/v1/', include('articles.urls')),
]
```

<br>

#### articles/models.py

- 게시글에 해당하는 Article 모델 작성

```python
from django.db import models

class Article(models.Model):
    title = models.CharField(max_length=100)
    content = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
```

- migrate

```shell
$ python manage.py makemigrations
$ python manage.py migrate
```

<br>

#### articles/serializers.py

- **serializer**
  - model instance를 사용하기 좋게끔 python native type으로 바꿔준다
  - dict, list등 변환 + 유효성 검사
- **ArticleListSerializer**
  - 전체 게시글 리스트를 보여준다
  - id, title만 보이도록 한다

```python
from rest_framework import serializers
from .models import Article

class ArticleListSerializer(serializers.ModelSerializer):

    class Meta:
        model = Article
        fields = ('id', 'title',)
```

<br>

## 1.1 Serializer 확인하기

> 전체 CRUD를 만들기에 앞서 어떻게 생겨먹은건지 알아야하지 않겠어요???
>
> `ArticleListSerializer로 어떤 것이 만들어졌는지` 확인해봅시다!!!

#### DB에 랜덤값 넣기

- seed <app_name> --number=<넣고싶은 데이터 수> 

```shell
$ python manage.py seed articles --number=20
```

#### shell-plus

- 실행

```shell
$ python manage.py shell_plus
```

- import serializer 
  - 자동으로 생성되지 않습니다!!

```shell
from articles.serializers import ArticleListSerializer
```

- serializer instance 생성

```shell
serializer = ArticleListSerializer()

serializer
#out
ArticleListSerializer():
    id = IntegerField(label='ID', read_only=True)  #읽을수만 있음
    title = CharField(max_length=100)
```

- serializer에 article instance 넣기

```python
article = Article.objects.get(pk=1)
serializer = ArticleListSerializer(article)
```

- data 확인
  - 1번 article이 dict형태로 출력됩니다!!
  - 실제 dict는 아니지만, 3번째에서 보이듯이 dict형태로 쓸 수 있습니다

```shell
serializer.data
# out
{'id': 1, 'title': 'Everything deep newspaper building.'}

type(serializer.data)
# out
rest_framework.utils.serializer_helpers.ReturnDict

serializer.data['id']
# out
1
```

<br>

<br>

## 1.2 CRUD 구현하자 :confetti_ball:

### :radio: READ

#### Main Page

> 모든 article list가 출력되는 부분입니다!!

- **articles/urls.py**

```python
from django.urls import path
from . import views

urlpatterns = [
    path('articles/', views.article_list),
]
```

- **articles/views.py - `article_list`**

  > 이전엔 article을 모두 가져와서 합친 뒤, html로 보여줬습니다
  >
  > 이번엔 합쳐주지 않고, **serializer를 통해 json 데이터**로 응답하겠습니다!!

  - **방식** :heavy_check_mark: 이대로 코드를 작성합시다
    1. article을 모두 가져온다
       - Article.objects.all() : 모든 article을 가져오며, 없으면 빈 배열
       - get_list_or_404(Article) : 모든 리스트 가져오며, 없으면 404에러
    2. json화할 수 있도록 변환
       - ArticleListSerializer(articles, many=True)
    3. 응답
       - Response(serializer.date) : dict형태로 들어감
  - api_view(['GET'])
    - rest_framework로 디자인할 때는 어떤 메서드로 받는지 반드시 명시해야 합니다

```python
@api_view(['GET'])
def article_list(request):
    articles = get_list_or_404(Article)
    serializer = ArticleListSerializer(articles, many=True)
    return Response(serializer.data)
```

