###### 210421_wed

##### APS 응용

<hr>
###### 오늘의 수업 목차 :ferris_wheel:

### 그래프

- 그래프 기본
- 그래프 탐색
- 서로소 집합들(Disjoint-Sets)
- 최소신장트리(MST) :star:
- 최단 경로 :star:

<hr>
<br>

# 1. 그래프 기본(Graph Basic)

## 1.1 그래프 :chart_with_upwards_trend:

- 아이템(사물 또는 추상적 개념)들과 이들 사이의 연결 관계를 표현
- **정점(Vertex)**들의 집합과 이들을 연결하는 **간선(Edge)**들의 집합으로 구성된 자료구조
  - |V| : 정점의 개수
  - |E| : 그래프에 포함된 간선의 개수
  - |V|개의 정점을 가지는 그래프는 최대 |V|* (|V| - 1) / 2개 간선 가능
  - 예) 4개의 정점
    - 하나는 최대 3개(|V| - 1 )
    - 최대 간선 수 = 3 + 2 + 1 = 4 * 3 / 2
- 선형 자료구조(배열)나 트리 자료구조(1:N)로 표현하기 어려운 **N : N 관계**를 가지는 원소들을 표현하기에 용이

<br>

### 그래프 유형

> 종류가 아주 많습니다!
>
> 뭐가 뭔지는 알아야겠죠?

- 무향 그래프 (Undirected Graph)
  - 방향이 없는, 정점에서 서로 이동 가능한
- 유향 그래프 (Directed Graph)
  - 방향이 있는, 화살표 방향으로만 이동 가능
- 가중치 그래프 (Weighted Graph)
  - 정점을 연결하는 간선에 weight 있는
  - 이동하는 비용
- 사이클 없는 방향 그래프 (DAG, Directed Acyclic Graph)
  - 사이클이 없는 (사이클 : 출발한 경로로 되돌아오는)
  - DAG조건

<img src="210421_graph.assets/image-20210421223206679.png" alt="image-20210421223206679" style="zoom:45%;" />

- 완전 그래프
  - 정점들에 대해 가능한 모든 간선들을 가진 그래프
  - 한 정점에서 다른 모든 것들과 연결 가능
- 부분 그래프
  - 원래 그래프에서 일부의 정점이나 간선을 제외한 그래프 (일부만 떼어낸 것)

<br>

### :family: 인접 정점

- 인접 (Adjacency)
  - 두 개의 정점(Vertex)에 **간선(Edge)이 존재**하는(연결된) 경우
  - 완전 그래프에 속한 임의의 두 정점들은 모두 인접해 있다
  - 실질적으로 **구현에 필요한 정보**!!! 

<br>

### 그래프 경로

- 간선들을 순서대로 나열한 것
  - **간선들**의 연결 : (0, 2), (2, 4), (4, 6)
  - **정점들**의 연결 : 0 - 2 - 4 - 6
- 단순 경로
  - 경로 중 한 정점을 `최대 한번`만 지나는 경로
  - 예) 0 - 2 - 4 - 6 / 0 - 1 - 6
- **사이클(Cycle)**
  - 시작한 정점에서 끝나는 경로
  - 예) 1 - 3 - 5 - 1

<br>

## 1.2 그래프 표현 :pencil:

> 그래프를 어떻게 나타낼 것인가?? 에 대한 문제

- 간선의 정보를 저장하는 방식
- 메모리나 성능을 고려하여 결정한다

#### 종류

- **인접 행렬** (Adjacent matrix)
  - |V| x |V| 크기의 `2차원 배열`을 이용하여 간선 정보 저장
  - 배열의 배열 (포인터 배열, C기준)
- **인접 리스트** (Adjacent List)
  - 각 `정점마다` 해당 정점으로 나가는 간선의 정보를 저장
- 간선의 배열
  - 간선(시작 정점, 끝 정점)을 배열에 연속적으로 저장

<br>

##### :cherries: 두 가지 방법을 적절히 활용합시다! :cherries:

<br>

### 인접 행렬 (Adjacent matrix)

- 두 정점을 연결하는 **간선의 유무**를 **행렬**로 표현
  - |V| x |V| 정방 행렬 (squar matrix)
  - **행 번호**와 **열 번호**는 그래프의 **정점에 대응**
  - 인접하면 1, 아니면 0으로 표현
- `무향` 그래프
  - *i*번째 행의 합 = *i*번째 열의 합 = V<sub>i</sub>의 차수 (차수 : 연결이 몇개나 있는지)
  - 간선 정보를 두 정점에 대해 모두 저장해야함
- `유향` 그래프
  - (보통) 행 : 출발 => 열 : 도착
  - 간선 정보를 한 방향(나가는)에 대해서만 저장
  - 행 *i*의 합 = V<sub>i</sub>의 진출 차수 (나가는 간선 개수)
  - 열 *i*의 합 = V<sub>i</sub>의 진입 차수 (들어오는 간선 개수)

그림 넣기

#### 단점 & 장점

- 빈 공간이 많다!!
  - 임의로 edge 지정해서 저장하면 빈 공간을 줄일 수 있다
- 단순하게 사용하기는 좋다

<br>

### 인접 리스트 (Adjacent List)

> 파이썬의 List와 구조적으로 유사합니다!!
>
> `행의 크기가 다른 모양이 될 수 있다`는 점에서 연결 리스트의 구조와 유사하기 때문에 사용할 수 있습니다!

- 각 정점에 대한 인접 정점들을 **순차적으로 표현**
- 하나의 정점에 대한 인접 정점들을 각각 노드로 하는 **연결 리스트로 저장**
- `무향` 그래프
  - 노드 수 = 간선 수 * 2 (양쪽에 연결되기때문)
  - 각 정점의 노드 수 = 정점의 차수
- `유향` 그래프
  - 노드 수 = 간선 수
  - 각 정점의 노드 수 = 정점의 진출 차수

그림

#### 장점?

- 행렬보다 저장 공간을 덜 사용한다!
- 1000짜리 배열(노드)까지 만들어서 사용한다고 합니다 

<br>

### 그래프 표현하기 :computer:





<br>

<br>

# 2. 그래프 탐색



<br>

<br>

# 3. 서로소 집합들 (Disjoint-sets)

> 이 부분은 뒤에서 다룰 최소신장트리에서 사용하게될거라 중요한 부분입니다!!

- 서로소 또는 상호배타 집합들은 **서로 중복 포함된 원소가 없는 집합들**이다
- 대표자 (**대표원소**, representative)
  - 집합에 속한 하나의 특정 멤버를 통해 **각 집합을 구분**
- 상호배타 집합을 **표현하는 방법**!!!
  - 연결 리스트
  - 트리 :heavy_check_mark: 
- 상호배타 `집합 연산`
  - Make-Set(x) : 만드는 것
  - Find-Set(x) : 대표원소 찾는 것
  - Union(x, y) : 합치는 것

#### 상호배타 집합 예

!!!!!!!!!!!!!!!!!!!!!!!!!그림이랑 채워넣기!!!!!!!!!!!!!!!!!!!!!!!!

- Make-Set(x) / Make-Set(y) / Make-set(a) / Make-Set(b)
  - 각각이 대표원소인 집합을 만든다
- Union(x, y) / Union(a, b)
  - 앞의 원소를 대표원소로 집합을 합친다
- Find-Set(y) => return x (representative)
  - 대표원소를 찾는다
- Find-Set(b) => return a (representative)
- Union(x, a)

<br>

## 3.1 상호배타 집합 표현 - 트리

- **하나의 집합**(a disjoint set)을 **하나의 트리**로 표현!!
  - 하나의 집합 : 서로 연결되어있는 것
- 자식 노드가 부모노드를 가르키며(아래에서 위로), `루트 노드가 대표원소`가 된다

<br>

<br>

# 4. 최소신장트리 (MST)



## 4.1 MST 표현



## 4.2 Prim 알고리즘



## 4.3 KRUSKAL 알고리즘



<br>

<br>

# 5. 최단 경로



## 5.1 Dijkstra 알고리즘



