###### 210405_mon

##### APS 기본

<hr>

###### 오늘의 수업 목차!

### 트리

- 트리
- 이진 트리
- 이진탐색 트리
- 힙

<hr>

<br>

# 1. 트리

> 트리는 `실생활에 정말 많이 쓰이는 구조`라고 합니다!!
>
> 한줄로 쭉 표현됐던 선형구조와 다른 트리에대해 알아봅시다!!!

### 트리의 개념

- `비선형` 구조
- 원소들 간에 1 : N 관계를 가지는 자료구조
- 원소들 간에 계층 관계를 가지는 계층형 자료구조(부모 - 자식)
- 상위원소에서 하위 원소로 내려가면서 확장되는 트리모양의 구조

## 1.2 정의

- 한 개 이상의 노드로 이루어진 유한집합
- 다음 조건을 만족한다
  - 노드 중 최상위 노드 = `루트(root)`
  - 나머지 노드들은 n(>= 0)개의 분리집합 T1, ..., TN으로 분리될 수 있다
- `subtree` : 각각 하나의 트리가 되는 T1, ..., TN / (재귀적 정의)루트의 subtree라 함

<img src="210405_1_tree.assets/image-20210406182111035.png" alt="image-20210406182111035" style="zoom:30%;" />

<br>

## 1.3 용어 정리

- **노드(node)** : 트리의 원소
- **간선(edge)** : 노드를 연결하는 선 (부모노드와 자식노드 연결)
  - 위쪽에 있는게 부모, 그 아래에 있으면 자식
- **루트 노드(root node)** : 트리의 시작 노드
  - `부모가 없는 노드`

  - 출발하는 노드 X

<img src="210405_1_tree.assets/image-20210406175317908.png" alt="image-20210406175317908" style="zoom:40%;" />

- **형제 노드(sibling node)** : 같은 부무 노드의 자식 노드들
- **조상노드** : 간선을 따라 루트 노드까지 이르는 경로에 있는 모든 노드들
  - 트리는 언젠가 만나기때문에 `공콩 조상`을 묻는 문제도 나옵니다
- **서브 트리(subtree)** : 부모 노드와 연결된 간선을 끊었을 때 생성되는 트리
  - 각각의 노드가 모두 서브트리가 될 수 있습니다
- **자손 노드** : 서브 트리에 있는 하위 레벨의 노드들
  - 자손이 없을 때까지 찾아가면서 만나는 모든 노드
  - B를 root로 하는 subtree에서 B를 제외한 나머지 모드

<img src="210405_1_tree.assets/image-20210406180136703.png" alt="image-20210406180136703" style="zoom: 40%;" />

- **차수(degree)**
  - 노드의 차수 : 노드에 연결괸 자식 노드의 수
  - 트리의 차수 :  트리에 있는 노드의 차수 중 가장 큰 값
  - `리프 노드 (leaf node, 단말노드)` : 차수가 0인 노드, 자식 노드가 없는 노드
- **높이**
  - 노드의 높이 : 루트에서 노드에 이르는 간선의 수 (노드의 레벨)
  - 트리의 높이 : 트리에 있는 노드의 높이 중 가장 큰 값, 최대 레벨

<img src="210405_1_tree.assets/image-20210406182207799.png" alt="image-20210406182207799" style="zoom:40%;" />

<br>

<br>

# 2. 이진트리 

> 1 : N은 너무 어렵잖아요... 1 : 2부터 시작합시다!
>
> 이진 탐색에 활용하는 이진트리!!!
>
> 자식이 2개 이상 되지 않도록 이미 구조가 나뉘어있기 때문에 매우 파워풀한 구조입니다!!

- 모든 노드들이 `2개의 서브트리`를 갖는 특별한 형태의 트리
- 각 노드가 `자식노드를 최대한 2개` 까지만 가질 수 있는 트리 
  - 왼쪽 자식 노드 (left child node)
  - 오른쪽 자식 노드(right child node)
- 기준이 없는 이진트리라면 왼쪽, 오른쪽 어디에 붙든 상관없습니다 (기준이 있다면 구분해야겠죠??)

예시 그림

<br>

## 2.1 특성

- 레벨 i에서의 노드의 최대 개수는 2<sup>i</sup> 개
- 높이가 h인 이진트리가 가질수 있는 노드
  - 최소 개수 : h + 1 개
  - 최대 개수 : (2<sup>h+1</sup>-1) 개

##### 최대개수 구하기??

- 등비수열로부터 나온 결과
- 2진수로 생각하면 더 쉽다
  - 레벨 0, 1, 2, 3의 각각 개수

그림넣기!!!

<br>

## 2.2 종류

### 포화 이진 트리 (Full Binary Tree)

> 이진트리가 꽉 차있다???
>
> 모든 레벨이 포화상태다 == 최대 노드 개수가 다 차있다

- `모든 레벨에 노드가 포화상태`로 차 있는 이진 트리
- 높이가 h일 때, **최대의 노드 개수인 (2<sup>h+1</sup>-1)의 노드를 가진 이진트리**

- 루트를 1번으로 하여 2<sup>h+1</sup>-1 까지 정해진 위치에 대한 노드 번호를 가짐

그림

<br>

### 완전 이진 트리 (Complete Binary Tree)

> 노드가 빠질수는 있다!!!
>
> 그렇지만 포화 이진 트리를 기준으로 1 ~ 특정 번호 까지 꽉 차있다.

- 높이가 h이고 노드수가 n일 때 (단, h + 1 <= n < 2<sup>h+1</sup>-1),  포화 이진 트리의 **노드 번호 1부터 n번까지 빈 자리가 없는 이진트리**
- 연속된 번호의 중간에 빈 번호가 생기면 안됩니다!

그림

<br>

### 편향 이진 트리 (Skewed Binary Tree)

> 한 줄로만 만들어지는 경우입니다!

- 높이 h에 대한 **최소 개수의 노드**를 가지면서, **한쪽 방향의 자식 노드만 가진** 이진트리
  - 왼쪽 편향 이진 트리
  - 오른쪽 편향 이진 트리
- 비선형의 장점을 잃은 (선형과 동일한) 구조

그림

<br>:sign

<br>

# 3. 순회(traversal)

- 트리의 각 노드를 **중복되지 않게 전부 방문(visit)**하는 것을 말함

- 트리는 비 선형 구조이기 때문에 선형구조에서와 같이 선후 연결 관계를 알 수 없습니다

  ##### :cherry_blossom: 그래서 사용할 3가지 특별한 방법

  - 전위 순회
  - 중위 순회
  - 후위 순회

<br>

## 3.1 개념

#### 순회 (traversal)

- 트리의 노드들을 **체계적으로 방문**하는 것

그림

#### 3가지 기본적인 순회방법

1. 전위 순회 (preorder traversal) : VLR
   - **부모노드 방문** 후, 자식노드를 **좌,우** 순서로 방문한다
2. 중위순회 (inorder traversal) : LVR
   - **왼쪽** 자식노드, **부모**노드, **오른쪽** 자식노드 순으로 방문한다
3. 후위순회 (postorder traversal) : LRV
   - 자식노드를 **좌우** 순서로 방문한 수, **부모**노드로 방문한다

<br>

##### :heavy_check_mark: 방문??

- 뭔가 필요한 동작(연산, 출력, 삽입 등)을 하는 것
- 그냥 지나가는 경우는 방문이라고 하지 않습니다!

<br>

## 3.2 순회 방식 :family_woman_girl_girl:

> 트리의 순회는 보통 `재귀`를 사용한다는 점!!
>
> 일반적으로 `부모에서 자식방향`으로 순회한다! (필요에따라 반대로 가기도 한다)

### 전위 순회(preorder traversal)

- 수행방법
  1.  `현재 노드` n을 `방문`하여 처리한다 => V 
  2. 현재 노드 n의 `왼쪽 서브트리`로 이동 => L
  3. 현재 노드 n의 `오른쪽 서브트리`로 이동 => R

- 알고리즘

  ```python
  def preorder(n):  #현재 노드 n
      if n:  # n이 유효한 노드인 경우(정의하기 나름)
          visit(n)  # 필요한 처리 (꺼내거나 집어넣는 등)
          preorder(n.left)  #왼쪽 자식으로 이동
          preorder(n.right)  #오른쪽 자식으로 이동
  ```

#### :facepunch: 예시

<img src="210405_1_tree.assets/image-20210408030746047.png" alt="image-20210408030746047" style="zoom:40%;" />

<br>

### 중위(inorder traversal)

- 수행방법
  1.  현재 노드 n의 `왼쪽 서브트리`로 이동 => L
  2. `현재 노드` n을 `방문`하여 처리한다 => V 
  3. 현재 노드 n의 `오른쪽 서브트리`로 이동 => R

- 알고리즘

  ```python
  def inorder(n):  #현재 노드 n
      if n:  # n이 유효한 노드인 경우(정의하기 나름)
          preorder(n.left)  #왼쪽 자식으로 이동
          visit(n)  # 필요한 처리 (꺼내거나 집어넣는 등)
          preorder(n.right)  #오른쪽 자식으로 이동
  ```

#### :facepunch: 예시

<img src="210405_1_tree.assets/image-20210408030857304.png" alt="image-20210408030857304" style="zoom:40%;" />

<br>

### 후위(postorder traversal)

- 수행방법
  1.  현재 노드 n의 `왼쪽 서브트리`로 이동 => L
  2. 현재 노드 n의 `오른쪽 서브트리`로 이동 => R
  3. `현재 노드` n을 `방문`하여 처리한다 => V 

- 알고리즘

  ```python
  def postorder(n):  #현재 노드 n
      if n:  # n이 유효한 노드인 경우(정의하기 나름)
          preorder(n.left)  #왼쪽 자식으로 이동
          preorder(n.right)  #오른쪽 자식으로 이동
          visit(n)  # 필요한 처리 (꺼내거나 집어넣는 등)
  ```

#### :facepunch: 예시

<img src="210405_1_tree.assets/image-20210408030804955.png" alt="image-20210408030804955" style="zoom:40%;" />

<br>

<br>

# 4. 이진트리의 표현

- **실제 메모리에 저장**하는 것에대한 이야기
- **부모와 자식 사이의 관계, 간선 정보**를 저장하는 것!
  - 어떤 노드 번호가 주어졌을 때, 자식의 번호가 뭔지 알 수 있으면 된다
- 일반적인 트리 : N개 노드에 대해 최대 자식 N - 1개(나를 제외한 나머지)
- **이진트리** : 자식 2개로 정해짐 (최대 **2개 저장할 공간**만 만들면 됨)

<br>

#### :cherries: 일반적인 트리순회에 대하여 :cherries:

- 부모에서 자식방향!! (유향그래프처럼)
  - 필요에 의해 자식에서 부모로 갈 수도 있음
  - 각 노드에 대해 `자식 유무`, `부모` 누구인지 정보를 저장해 놓음!
- 트리순회에서 방문표시?? **놉!!**
  - `한 방향으로만 순회`하기때문에, 부모와 자식이 뒤바뀌어 저장되지 않음!!!
- 트리는 사이클(ex. B의 자식 D, E가 연결된 경우 형성)이 없다
  - 따라서 한 번 방문한 곳을 또 방문할 일 없음!
- `단말노드(리프노드)`에 도착한 경우???
  - 지금 보는 노드가 **단말노드인지 아닌지 **돌아가야함!!
  - 단말 노드에 공백 노드(NULL)을 붙여준다 :heavy_check_mark: 보통 이렇게 한다

<br>

#### 배열을 이용한 이진 트리의 표현 (포화 이진 트리)

> 배열을 이용해서 이진 트리를 저장하는 방법을 알아보자!!

- 이진 트리에 각 노드 번호를 다음과 같이 부여
  - 루트 번호 : 1
  - 레벨 n에 있는 노드에 대하여, 왼쪽부터 오른쪽으로 2<sup>n</sup>부터 2<sup>n+1</sup>-1까지 번호를 차례대로 부여
- 즉, `포화 이진 트리` or `완전 이진 트리`의 노드번호를 따라 저장하는 경우 이와같은 형식으로 사용하면 된다!

<img src="210405_1_tree.assets/image-20210408033834227.png" alt="image-20210408033834227" style="zoom:40%;" />

<br>

## 4.1 배열

> 배열을 이용해 이진트리를 표현하자

### 노드 번호의 성질

> 현재 노드 번호 `i`

- `자식 노드` 번호 계산
  - 왼쪽 자식 :  `i * 2`
  - 오른쪽 자식 : `i * 2 + 1`
- `부모 노드` 번호 계산 : `i // 2` (⌊i/2⌋) 

<img src="210405_1_tree.assets/image-20210408221724463.png" alt="image-20210408221724463" style="zoom:40%;" />

#### 배열을 이용한 트리 표현의 단점!!!

> 편향이진트리 같은 경우!!!

- 메모리 공간 낭비가 너무 심함!
- 새로운 노드를 삽입하거나 내용을 바꿔야한다거나 하면 사용하기 불편
- 완진히 노드가 고정된 경우에만 사용하는 것이 좋다!!

<br>

<br>

## 4.2 연결리스트

> 배열을 이용한 이진 트리 표현의 단점을 보완하기 위해 연결리스트를 이용하여 트리를 표현할 수 있다!!!

- 연결 자료구조를 이용한 이진트리의 표현
  - 이진 트리의 모든 노드는 최대 2개의 자식 노드를 가지므로 일정한 구조의 단순 연결 리스트 노드를 사용하여 구현

- 완전 이진 트리의 연결 리스트 표현

<그림>



<br>

<br>

## 4.3 문제 풀어보기

### :penguin: 문제

- 첫 줄에는 트리의 정점의 총 수 V가 주어진다. (정점개수 = 간선 + 1)
- 다음 줄에는 V-1개의 간선이 나열된다
- 간선은 항상 `부모 자식`순서로 표기된다
- 부모 정점 번호가 작은 것부터 나열되고, 부모 정점이 동일하다면 자식 정점 번호가 작은 것부터 나열된다

##### :male_detective: 이진 트리 표현에 대하여 전위 순회하여 정점의 번호를 출력하시오. :male_detective: 

### :icecream: 입력 / 출력

```python
## 입력
13  #정점의 개수
1 2 1 3 2 4 3 5 3 6 4 7 5 8 5 9 6 10 6 11 7 12 11 13

## 출력
1 2 4 7 12 3 5 8 9 6 10 11 13 
```

<br>

### :ice_cream: 답변

