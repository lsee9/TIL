###### 210405_mon

##### APS 기본

<hr>

###### 오늘의 수업 목차!

### 트리

- 트리
- 이진 트리
- 이진탐색 트리
- 힙

<hr>

<br>

# 1. 트리

> 트리는 `실생활에 정말 많이 쓰이는 구조`라고 합니다!!
>
> 한줄로 쭉 표현됐던 선형구조와 다른 트리에대해 알아봅시다!!!

### 트리의 개념

- `비선형` 구조
- 원소들 간에 1 : N 관계를 가지는 자료구조
- 원소들 간에 계층 관계를 가지는 계층형 자료구조(부모 - 자식)
- 상위원소에서 하위 원소로 내려가면서 확장되는 트리모양의 구조

## 1.2 정의

- 한 개 이상의 노드로 이루어진 유한집합
- 다음 조건을 만족한다
  - 노드 중 최상위 노드 = `루트(root)`
  - 나머지 노드들은 n(>= 0)개의 분리집합 T1, ..., TN으로 분리될 수 있다
- `subtree` : 각각 하나의 트리가 되는 T1, ..., TN / (재귀적 정의)루트의 subtree라 함

<img src="210405_1_tree.assets/image-20210406182111035.png" alt="image-20210406182111035" style="zoom:30%;" />

<br>

## 1.3 용어 정리

- **노드(node)** : 트리의 원소
- **간선(edge)** : 노드를 연결하는 선 (부모노드와 자식노드 연결)
  - 위쪽에 있는게 부모, 그 아래에 있으면 자식
- **루트 노드(root node)** : 트리의 시작 노드
  - `부모가 없는 노드`

  - 출발하는 노드 X

<img src="210405_1_tree.assets/image-20210406175317908.png" alt="image-20210406175317908" style="zoom:40%;" />

- **형제 노드(sibling node)** : 같은 부무 노드의 자식 노드들
- **조상노드** : 간선을 따라 루트 노드까지 이르는 경로에 있는 모든 노드들
  - 트리는 언젠가 만나기때문에 `공콩 조상`을 묻는 문제도 나옵니다
- **서브 트리(subtree)** : 부모 노드와 연결된 간선을 끊었을 때 생성되는 트리
  - 각각의 노드가 모두 서브트리가 될 수 있습니다
- **자손 노드** : 서브 트리에 있는 하위 레벨의 노드들
  - 자손이 없을 때까지 찾아가면서 만나는 모든 노드
  - B를 root로 하는 subtree에서 B를 제외한 나머지 모드

<img src="210405_1_tree.assets/image-20210406180136703.png" alt="image-20210406180136703" style="zoom: 40%;" />

- **차수(degree)**
  - 노드의 차수 : 노드에 연결괸 자식 노드의 수
  - 트리의 차수 :  트리에 있는 노드의 차수 중 가장 큰 값
  - `리프 노드 (leaf node, 단말노드)` : 차수가 0인 노드, 자식 노드가 없는 노드
- **높이**
  - 노드의 높이 : 루트에서 노드에 이르는 간선의 수 (노드의 레벨)
  - 트리의 높이 : 트리에 있는 노드의 높이 중 가장 큰 값, 최대 레벨

<img src="210405_1_tree.assets/image-20210406182207799.png" alt="image-20210406182207799" style="zoom:40%;" />

<br>

<br>

# 2. 이진트리 

> 1 : N은 너무 어렵잖아요... 1 : 2부터 시작합시다!
>
> 이진 탐색에 활용하는 이진트리!!!
>
> 자식이 2개 이상 되지 않도록 이미 구조가 나뉘어있기 때문에 매우 파워풀한 구조입니다!!

- 모든 노드들이 `2개의 서브트리`를 갖는 특별한 형태의 트리
- 각 노드가 `자식노드를 최대한 2개` 까지만 가질 수 있는 트리 
  - 왼쪽 자식 노드 (left child node)
  - 오른쪽 자식 노드(right child node)
- 기준이 없는 이진트리라면 왼쪽, 오른쪽 어디에 붙든 상관없습니다 (기준이 있다면 구분해야겠죠??)

예시 그림

<br>

## 2.1 특성

- 레벨 i에서의 노드의 최대 개수는 2<sup>i</sup> 개
- 높이가 h인 이진트리가 가질수 있는 노드
  - 최소 개수 : h + 1 개
  - 최대 개수 : (2<sup>h+1</sup>-1) 개

##### 최대개수 구하기??

- 등비수열로부터 나온 결과
- 2진수로 생각하면 더 쉽다
  - 레벨 0, 1, 2, 3의 각각 개수

그림넣기!!!

<br>

## 2.2 종류

### 포화 이진 트리 (Full Binary Tree)

> 이진트리가 꽉 차있다???
>
> 모든 레벨이 포화상태다 == 최대 노드 개수가 다 차있다

- `모든 레벨에 노드가 포화상태`로 차 있는 이진 트리
- 높이가 h일 때, **최대의 노드 개수인 (2<sup>h+1</sup>-1)의 노드를 가진 이진트리**

- 루트를 1번으로 하여 2<sup>h+1</sup>-1 까지 정해진 위치에 대한 노드 번호를 가짐

그림

<br>

### 완전 이진 트리 (Complete Binary Tree)

> 노드가 빠질수는 있다!!!
>
> 그렇지만 포화 이진 트리를 기준으로 1 ~ 특정 번호 까지 꽉 차있다.

- 높이가 h이고 노드수가 n일 때 (단, h + 1 <= n < 2<sup>h+1</sup>-1),  포화 이진 트리의 **노드 번호 1부터 n번까지 빈 자리가 없는 이진트리**
- 연속된 번호의 중간에 빈 번호가 생기면 안됩니다!

그림

<br>

### 편향 이진 트리 (Skewed Binary Tree)

> 한 줄로만 만들어지는 경우입니다!

- 높이 h에 대한 **최소 개수의 노드**를 가지면서, **한쪽 방향의 자식 노드만 가진** 이진트리
  - 왼쪽 편향 이진 트리
  - 오른쪽 편향 이진 트리
- 비선형의 장점을 잃은 (선형과 동일한) 구조

그림

<br>:sign

<br>

# 3. 순회(traversal)

- 트리의 각 노드를 **중복되지 않게 전부 방문(visit)**하는 것을 말함

- 트리는 비 선형 구조이기 때문에 선형구조에서와 같이 선후 연결 관계를 알 수 없습니다

  ##### :cherry_blossom: 그래서 사용할 3가지 특별한 방법

  - 전위 순회
  - 중위 순회
  - 후위 순회

<br>

## 3.1 개념

#### 순회 (traversal)

- 트리의 노드들을 **체계적으로 방문**하는 것

그림

#### 3가지 기본적인 순회방법

1. 전위 순회 (preorder traversal) : VLR
   - **부모노드 방문** 후, 자식노드를 **좌,우** 순서로 방문한다
2. 중위순회 (inorder traversal) : LVR
   - **왼쪽** 자식노드, **부모**노드, **오른쪽** 자식노드 순으로 방문한다
3. 후위순회 (postorder traversal) : LRV
   - 자식노드를 **좌우** 순서로 방문한 수, **부모**노드로 방문한다

<br>

##### :heavy_check_mark: 방문??

- 뭔가 필요한 동작(연산, 출력, 삽입 등)을 하는 것
- 그냥 지나가는 경우는 방문이라고 하지 않습니다!

<br>

## 3.2 순회 방식 :family_woman_girl_girl:

> 트리의 순회는 보통 `재귀`를 사용한다는 점!!

### 전위 순회(preorder traversal)

- 수행방법
  1.  `현재 노드` n을 `방문`하여 처리한다 => V 
  2. 현재 노드 n의 `왼쪽 서브트리`로 이동 => L
  3. 현재 노드 n의 `오른쪽 서브트리`로 이동 => R

- 알고리즘

  ```python
  def preorder(n):  #현재 노드 n
      if n:  # n이 유효한 노드인 경우(정의하기 나름)
          visit(n)  # 필요한 처리 (꺼내거나 집어넣는 등)
          preorder(n.left)  #왼쪽 자식으로 이동
          preorder(n.right)  #오른쪽 자식으로 이동
  ```

#### :facepunch: 예시



<br>

### 중위(inorder traversal)

- 수행방법
  1.  현재 노드 n의 `왼쪽 서브트리`로 이동 => L
  2. `현재 노드` n을 `방문`하여 처리한다 => V 
  3. 현재 노드 n의 `오른쪽 서브트리`로 이동 => R

- 알고리즘

  ```python
  def inorder(n):  #현재 노드 n
      if n:  # n이 유효한 노드인 경우(정의하기 나름)
          preorder(n.left)  #왼쪽 자식으로 이동
          visit(n)  # 필요한 처리 (꺼내거나 집어넣는 등)
          preorder(n.right)  #오른쪽 자식으로 이동
  ```

#### :facepunch: 예시



<br>

### 후위(postorder traversal)

- 수행방법
  1.  현재 노드 n의 `왼쪽 서브트리`로 이동 => L
  2. 현재 노드 n의 `오른쪽 서브트리`로 이동 => R
  3. `현재 노드` n을 `방문`하여 처리한다 => V 

- 알고리즘

  ```python
  def postorder(n):  #현재 노드 n
      if n:  # n이 유효한 노드인 경우(정의하기 나름)
          preorder(n.left)  #왼쪽 자식으로 이동
          preorder(n.right)  #오른쪽 자식으로 이동
          visit(n)  # 필요한 처리 (꺼내거나 집어넣는 등)
  ```

#### :facepunch: 예시



<br>

<br>

# 4. 이진트리의 표현