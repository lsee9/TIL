###### 210407_wed

##### Computational Thinking

###### 기초 논리 & 수학

<hr>


###### 수업 목차

0. 서론 - 프로그래밍과 놀리/수학
1. 논리와 증명
2. 수와 표현
3. 집합과 조합론
4. 기초 수식
5. 재귀
6. 동적 프로그래밍

<hr>

<br>

### 서문

- Dijkstra 알고리즘, 아무리봐도 잘 모르겠다
- 프로그램을 따면서 뭐가 더 빠른지 느린지 감이 없다
- Problem Solving 자료를 보고 시간을 들여도 발전이 없다

:detective: 이는 **논리적**으로 **정확하게 확인**하는 과정에 대한 연습이 없었기 때문!!

- 프로그램을 짜기 전, 정확한 결과가 나올지, 얼마나 빠를지 알아야 프로그래밍도 더 쉬워진다!
- 이를 모른다면... 오류나 다른 결과가 나왔을 때 무작정 여러 시도를 하는 수밖에 없다는거
- 그래서 오늘 수업은 이를 위한 기초 연습이다!
- 이걸로 내가 이제 모든 문제를 정확히 할 수 있어!!!!는 불가능하지만... 나중에 필요하다면 이를 위한 아주 기본 지식으로는 도움이 될 것이다

##### :penguin: 기초를 배우고 문제를 풀어봅시다! :penguin:

<br>

<br>

# 0. 서론

#### 프로그래밍의 어려운 점?

- 라이브러리
- 논리





### 증명



### 수학적 귀납법





# 1. 논리와 증명



<br>

<br>

# 2. 수와 표현

### 비트와 로그

- 컴퓨터 : 기억장치의 기본 단위가 `0`, `1` (최소한의 저장 단위가 0, 1), 따라서 비트를 모아 수를 표현
- k개의 비트 사용 : 0 ~ 2<sup>k</sup>-1까지 표현 가능
  - 예) 2비트 : 00/01/10/11 => 0/1/2/3 즉, 2<sup>2</sup>-1까지 표현

##### :thinking: 어떤 값 n을 표현하기 위해 필요한 비트수??

- 2<sup>k</sup>-1 >= n , 즉 **2<sup>k</sup>  >= n + 1** 이 성립해야함!!
- 따라서 k >= log(n + 1) => 약 **log n**비트 필요

- x = log n <=> 2<sup>k</sup> = n  (밑이 2인 로그를 사용하기때문에 서로 같은 말)
- x = log n 일 때, x < n이고 n이 커질수록 엄청 달라진다
- 100자리로 표현할 수 있는 10진수 값은 읽을 수 없을 정도로 큰 값!! log를 사용해서 작게 표현한다

#### log n

- 2의 몇 승이 n이 되느냐
- n을 표현하는 데 몇 비트가 필요한가
- 1로 시작해서 계속 두 배를 할 때, 몇 번하면 n이 되느냐
- n을 계속 2로 나눌 때, 몇 번 나누면 거의 1이 되느냐

#### bit의 경우의 수

- 주소공간 : 32bit / 64git
  - 다룰 수 있는 메모리 주소의 크기를 바탕으로 한다(주소접근하는 크기)
  - 32bit => 2<sup>32</sup> = 약 40억개 주소
- n + (n/2 + n/2) + (n/4 + n/4 + n/4 + n/4) + (n/8 + n/8 ...) + ... + (1 + 1 + ...) = *n*log*n*
  - 0 + 1 + 2 + 3 + ... + n으로 번호를 붙일 수 있음
  - 2<sup>k</sup>의 분모에 대해 k로 번호를 나타낼 수 있음!
  - 마지막 n/n => 2<sup>k</sup> = n이어야 한다는 것!!!
  - 

<br>

<br>