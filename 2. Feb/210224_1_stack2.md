210224_wed

# APS 5

> 5차시!!! 오늘은 그나마 열심히 들은 것 같기두!

<br>

# Stack2

> `스택`자료구조를 좀 더 활용해봅시다@@@

- 계산기
- 백트래킹
- 분할정복

<br>

<br>

# 1. 계산기

> 수식을 계산하는 방식을 알아보고, 계산기를 구현해봅시다!

- __문자열로 된 계산식__이 주어질 때, __스택을 이용__하여 이 계산식의 __값을 계산__할 수 있다!!

## 1.1 문자열 수식 계산의 일반적인 방법

### step 1

- 중위 표기법의 수식을 후위 표기법으로 변경 (스택 이용)

### step 2
- 후위 표기법의 수식을 스택을 이용하여 계산

#### 두가지 표기법

- 중위표기법(infix notation)

  - 연산자를 피연산자의 가운데 표기하는 방법(일반적인 식의 표현법)

    예) A + B

- 후위표기법(postfix notation)

  - 연산자를 피연산자 귀에 표기하는 방법

    예) AB*

  - 컴퓨터가 읽을 수 있는 계산식으로, 괄호가 필요없다

<br>

## 1.2 중위표기식의 후위표기식 변환(step 1)

### 1.2.1 방법1

1. 수식의 각 연산자에 대해서 우선순위에 따라 __괄호를 사용하여 표현__

2. 각 연산자를 그에 대응하는 오른쪽 괄호 뒤로 이동시킴

3. 괄호 제거

#### 예) A*B+C/D

1. ((A*B)+(C/D))
2. ((AB)*+(CD)/)
3. AB*+CD/

<br>

### 1.2.2 방법2 - 스택을 이용한 알고리즘

1. 입력받은 중위 표기식에서 토큰을 읽는다
2. 토큰이 __피연산자__이면 __출력__
3. 토큰이 __연산자(괄호 포함)__인 경우
   - __토큰__의 우선순위 __>__ __스택 top__ 연산자의 우선순위
     - 토큰을 스택에 push
   - 토큰의 우선순위 __<=__ 스택 top 연산자의 우선순위
     - (토큰의 우선순위 > 스택 top 연산자의 우선순위)이 성립할 때까지, top의 연산자를 __pop하여 출력__한 뒤, __토큰을 push__한다
   - top연산자가 없는 경우 push

4. 토큰이 __')' 오른쪽 괄호__인경우

   - 스택 top에 왼쪽 괄호 '('가 올 때까지 pop수행, pop한 연산자는 출력

   - '(' 왼쪽 괄호를 만나면 pop만하고 출력하지 않음

5. 중위표기식에 더 읽을 것이 없다면 중지, 더 읽을 것이 있다면 1부터 다시 반복
6. 스택에 남아있는 연산자를 모두 pop하여 출력

##### 주의 :star: - 왼쪽 괄호'(' 의 우선순위

- 스택 밖 : 가장 높음 (무조건 push 하기 위함)
- 스택 안 : 가장 낮음 (다른 연산자가 무조건 push되도록 하기 위함)

방식을 그림으로 표현...하면 좋은데 넘나 귀찮...ㅎㅎ

<br>

## 1.3 스택을 이용한 후위표기식 계산 (step 2)

### 1.3.1 방법

1. __피연산자__를 만나면 스택에 __push__
2. __연산자__를 만나면
   - 필요한 만큼 피연산자를 스택에서 __pop하여 연산__
   - 연산__결과__를 다시 스택에 __push__

3. 수식이 끝나면, 마지막으로 __스택을 pop하여 출력__ (마지막 연산 결과 출력)

그림으로 표현하면 아주 좋긴해...

<br>

## 1.4 계산기 구현

- step 1, 2를 기반으로 전체적인 계산기를 구현한다

#### calculator_input.txt

- 첫줄에는 중위표기식의 길이 N이 주어진다
- 다음 줄에는 우선순위에 따라 괄호로 묶은 중위표기식이 주어진다
- 피연산자는 1~9사이의 한자리 숫자이다
- 나눗셈의 경우 소수점은 버린다

```python
21
(((2*4)+(3*5))-(4/2))  #계산 결과 = 21
```

### 구현

```python
import sys; sys.stdin = open('calculator_input.txt', 'r')

operator = {'+', '-', '*', '/', '(', ')'}

in_S = {'+': 1, '-': 1, '*': 2, '/': 2, '(': 0}  #스택 내부 우선순위
out_S = {'+': 1, '-': 1, '*': 2, '/': 2, '(': 3}  #스택 외부 우선순위

for tc in range(1, 11):
    N = int(input())  #수식의 길이
    infix = input()  #중위표기식
    S = []  #스택
    postfix = ''  #후위표기식 저장할 변수
    
    for op in infix:
        if op in operator:  #operator인경우
            if op == ')':  #닫는 괄호이면
                while S[-1] != '(':  #스탣 가장 위의 값이 여는 괄호일때까지 pop하여 빼줌
                    postfix += S.pop()
                S.pop()  #여는 괄호 제거
            else:  #다른 연산자인 경우
                while S and in_S[S[-1]] >= out_S[op]:  #스택이 비어있지 않고, 내부 요소의 우선순위가 더 큰경우
                    postfix += S.pop()  #pop하여 붙임
                S.append(op)  #스택에 연산자 저장
        else:
            postfix += op  #피연산자는 수식에 바로 저장
    #스택이 빌때까지 요소를 빼서 저장함
    while S:
        postfix += S.pop()

    #후위표기식 계산
    for op in postfix:
        #연산자인경우 2개의 피연산자 pop
        if op in operator:
            b = S.pop()
            a = S.pop()
            #연산자에 맞게 계산한 뒤 스택에 push
            if op == '+': S.append(a + b)
            elif op == '*': S.append(a * b)
            elif op == '-': S.append(a - b)
            else: S.append(a // b)
        else:
            #피연산자를 정수형으로 스택에 push
            S.append(int(op))

    #마지막에 남은 값이 계산 결과
    print('#{} {}'.format(tc, S.pop()))
```

