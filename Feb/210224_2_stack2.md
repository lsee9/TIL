210224_wed

# APS 5

> 힘을 냅시다아ㅏ

<br>

# Stack2

> `스택`자료구조를 좀 더 활용해봅시다@@@

- 계산기
- 백트래킹
- 분할정복

<br>

<br>

# 2. 백트래킹(Backtracking)

- 해를 찾는 도중에 `막히면` (즉, 해가 아니면) __되돌아가서 다시 해를 찾아__ 가는 기법

- 최적화(optimization) 문제와 결정(decision)문제를 해결할 수 있다

#### 결정문제

- 문제의 조건을 만족하는 해가 존재하는지 여부를 yes 또는 no가 답하는 문제
- 예시
  - 미로 찾기 - 탈출구가 있나 없나
  - n-Queen 문제 - NxN배열, N개의 Queen을 공격범위에 들어가지 않게 놓을 수 있는지 없는지
  - Map coloring
  - 부분 집합의 합(Subset Sum)문제

<br>

## 2.1 미로찾기

- 입구와 출구가 주어진 미로에서 __입구부터 출구까지의 경로를 찾는__ 문제
- 이동할 수 있는 방향은 4방향으로 제한(대각선은 연결된게 아님)
- 1은 벽, 0은 길을 의미
- 각 칸을 정점으로 생각하고, 연결되어있나 아닌가를 생각해볼 수 있음!
- 미로의 테두리를 1로 두름(선택)
  - 이렇게하면 4방향 탐색시, 인덱스 범위를 벗어날 걱정은 하지 않아도 됨

그림...!!!

<br>

## 2.2 백트래킹의 특징

### 2.2.1 백트래킹과 깊이우선탐색(DFS)의 차이

- 가지치기(Prunning)
  - 어떤 노드에서 출발하는 경로가 __해결책으로 이어질 것 같지 않으면__ 더 이상 그 경로를 __따라가지 않음__으로써 __시도의 횟수를 줄임__
- 비교
  - DFS : 모든 경로를 추적
    - N!의 너무 많은 경우의 수, 12만되어도 매우 커서 처리 불가능
  - BFS : 불필요한 경로를 조기에 차단
    - 일반적으로 경우의 수가 줄어들긴 하지만 만능은 아님
    - 최악의 경우 지수함수시간을 요하거나 정답마저 걸러내어 처리 불가능
  - 둘 다 기본적으로 완전 탐색이기는 하나, 백트래킹은 답일거라고 생각하는 것만 확인함

<img src="210224_2_stack2.assets/image-20210307025344561.png" alt="image-20210307025344561" style="zoom:40%;" />

### 2.2.2 백트래킹 기법

- 가지치기(pruning) : 유망하지 않은 노드가 포함된 경로는 더이상 고려하지 않음
  - 어떤 노드의 유망성(정답으로 갈 수 있는지 없는지)을 점검한 후, __유망(promising)하지 않다__고 결정되면 그 노드의 __부모노드로 되돌아가(backtracking)__ 다음 자식 노드로 감
- 어떤 노드를 방문했을 때,
  - 유망하다 : 그 노드를 포함한 경로가 해답의 가능성이 있다
  - 유망하지 않다 : 그 노드를 포함한 경로가 해답이 될 수 없다

### 2.2.3 백트래킹 절차

1. 상태 공간 트리의 __깊이 우선 탐색을 실시__한다

2. 각 노드가 유망한지를 점검한다
3. 만일 그 노드가 유망하지 않다면, 그 노드의 부모 노드로 돌아사 검사를 계속한다

#### 일반 백트래킹 알고리즘

- 모든 백트래킹을 이렇게 짤 필요는 없습니다
- 보통 DFS를 재귀로 구현하며, 해당 알고리즘에서 v가 유망한지 확인하는 과정이 추가된 형태입니다

```python
def backtracking(v):  #현재 노드를 입력으로 받음
    if promising(v):  #v가 유망한 경우
        if there is a solution at v:  #v에 답이 있는경우
            print solution
            end
        else:
            for u in child of v:  #v의 자식 노드 확인
                backtraking(v)
```

<br>

<br>

## 2.3 N-Queen

> backtrcking을 이용하여 N-Queen문제를 해결해봅시다!

- Queen : 상하좌우, 대각선으로 이동 가능
- NxN 보드에서 N개의 Queen이 서로의 공격범위에 들지 않도록 배치하는 경우의 수는 몇개일까?

### N = 4인 경우를 생각해보자

#### 완전탐색

- 방식 설명 ~

#### backtracking 적용

- 방식 설명

<br>

<br>

## 2.4 부분집합 구하기

- __powerset__ : 어떤 집합의 공집합과 자기자신을 포함한 모든 부분집합
  - 구하고자 하는 어떤 집합의 원소 개수가 n일 경우 부분집합의 개수는 __2<sup>n</sup>__

### 2.4.1 백트래킹으로 powerset 구하기

- 일반적인 백트래킹 접근 방법을 이용
- 원소가 부분집합의 값인지 아닌지 판단 필요
  - n개의 원소에대해 True 또는 False를 가지는 n개의 배열을 만듦
  - 해당 배열의 i 번째 한목은 i번째 원소가 부분집합의 값인지 아닌지를 나타내는 값

#### 이전에 배운 생성방법 2가지

- 중첩된 for문 사용

```python
N = 4
bit = [1, 2, 3, 4]
for i in range(2):  #각 자리는 0, 1 2가지 선택지를 가짐
    bit[0] *= i
    for j in range(2):
        bit[1] *= j
        for k in range(2):
            bit[2] *= k
            for l in range(2):
                bit[3] *= l
                print(bit)  #생성된 부분집합 출력
```

```python
#출력
[0, 0, 0, 0]
[0, 0, 0, 1]
[0, 0, 1, 0]
[0, 0, 1, 1]
[0, 1, 0, 0]
[0, 1, 0, 1]
[0, 1, 1, 0]
[0, 1, 1, 1]
[1, 0, 0, 0]
[1, 0, 0, 1]
[1, 0, 1, 0]
[1, 0, 1, 1]
[1, 1, 0, 0]
[1, 1, 0, 1]
[1, 1, 1, 0]
[1, 1, 1, 1]
```
- 중첩 for문 bit원소 값으로 부분집합 표현
```python
N = 4
bit = [1, 2, 3, 4]
sel = [0] * N
for i in range(2):  #각 자리는 0, 1 2가지 선택지를 가짐
    sel[0] = bit[0] * i
    for j in range(2):
        sel[1] = bit[1] * j
        for k in range(2):
            sel[2] = bit[2] * k
            for l in range(2):
                sel[3] = bit[3] * l
                print(sel)  #생성된 부분집합 출력
```

```python
#출력
[0, 0, 0, 0]
[0, 0, 0, 4]
[0, 0, 3, 0]
[0, 0, 3, 4]
[0, 2, 0, 0]
[0, 2, 0, 4]
[0, 2, 3, 0]
[0, 2, 3, 4]
[1, 0, 0, 0]
[1, 0, 0, 4]
[1, 0, 3, 0]
[1, 0, 3, 4]
[1, 2, 0, 0]
[1, 2, 0, 4]
[1, 2, 3, 0]
[1, 2, 3, 4]
```

- bit연산자 사용

```python
N = 4
bit = [1, 2, 3, 4]
for i in range(1 << N):  #2^N개의 경우의 수 확인
    for j in range(N):
        if i & (1 << j):  #j번째 원소를 포함하는 경우
            print(bit[j], end = ' ')  #해당 값을 부분집합으로 출력
    print()
```

```python
# 출력
  #공집합
1 
2 
1 2 
3 
1 3 
2 3 
1 2 3 
4 
1 4 
2 4 
1 2 4 
3 4 
1 3 4 
2 3 4 
1 2 3 4  #자기자신
```

<br>

####  backtrackig 이용한 구현

- 재귀로 구현하기

```python
N = 4  # 전체 데이터의 개수
M = 4  # 부분집합의 원소개수
arr = [1, 2, 3, 4]  # 부분집합을 만들 데이터
check = [0] * N  # 값의 사용 여부를 저장할 리스트

def powerset_rec(idx):  # 뽑을 위치를 매개변수로
    if idx == M:  # M번뽑았으면 부분집합 출력
        for i in range(N):
            if check[i]:
                print(arr[i], end=' ')
        print()
        return

    check[idx] = 0  #idx를 뽑지 않고 다음위치로
    powerset_rec(idx + 1)
    check[idx] = 1  #idx를 뽑고 다음 위치로
    powerset_rec(idx + 1)

powerset_rec(0)  #0번위치부터 시작
```

```python
#출력

4 
3 
3 4 
2 
2 4 
2 3 
2 3 4 
1 
1 4 
1 3 
1 3 4 
1 2 
1 2 4 
1 2 3 
1 2 3 4 
```

<br>

#### 백트래킹을 구현할 때 생각할 것

- __상태공간트리__를 잘 구현해야함
  - 모든 경우의 수를 따지는 과정을 트리형태로 모딜링하고, 트리를 탐색하는 과정을 코드로 구현하는 것
  - 트리는 그래프의 subset
    - 그래프 탐색 : DFS, BFS로 수행

- 최적화 문제를 풀때 사용
  - 초기상태, 목표상태가 주어졌을 때, 어떤 선택으로 상태를 바꿔가며 목표 상태에 도달해야함
  - 각 상태를 하나의 정점으로 표현, 다른 상태로 넘어가는 관계는 간선으로 표현
  - 초기상태에서 목표상태로 가는 경로를 찾는 문제로 볼 수 있다

- 4-Queen의 상태공간트리를 그려볼까?

그림...???

<br>

<br>

## 2.5 순열 구하기

### 순열

- 서로 다른 n개에서 r개를 뽑아 일렬로 나열하는 경우의 수
- 숫자는 1번씩만 사용할 수 있으며, 같은 구성이라도 순서가 다르면 다른 경우로 본다

#### 단순한 순열 구현 - 중첩 for문

- {1, 2, 3}을 포함하는 모든 순열을 생성하자

```python
N = 3
for i in range(1, N + 1):  #i를 택한다
    for j in range(1, N + 1):
        if j != i:  #i랑 같지 않은 j를 택한다
            for k in range(1, N + 1):
                if k != i and k != j:  #i, j와 다른 k를 택한다
                    print([i, j, k])
```

```python
# 출력
[1, 2, 3]
[1, 3, 2]
[2, 1, 3]
[2, 3, 1]
[3, 1, 2]
[3, 2, 1]
```

